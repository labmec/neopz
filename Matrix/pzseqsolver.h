/**
 * @file
 * @brief Contains TPZSequenceSolver class which defines sequence solvers.
 */
/* Generated by Together */

#ifndef TPZSEQUENCESOLVER_H
#define TPZSEQUENCESOLVER_H
#include "pzsolve.h"
#include "pzstack.h"

template<class TVar>
class TPZFMatrix;

/** 
 * @ingroup solver
 * @brief Id for sequence solver
 */
#define TPZSQUENCESOLVER_ID 29281006

/**
 * @brief Defines sequence solvers. \ref solver "Solver"
 * @ingroup solver
 */
template <class TVar>
class TPZSequenceSolver : public TPZMatrixSolver<TVar> {
public:
	/**
     * @brief Constructor with initialization parameter
     * @param refmat Sets reference matrix to NILL
	 */
	TPZSequenceSolver(TPZMatrix<TVar> *refmat = 0);
	/**
     * @brief Copy constructor
     * @param copy Model object to be copied from
	 */
	TPZSequenceSolver(const TPZSequenceSolver<TVar> & copy);
	
	void Solve(const TPZFMatrix<TVar> &F, TPZFMatrix<TVar> &result, TPZFMatrix<TVar> *residual = 0);
	
	/** @brief This method will reinitialize the solver object, including the solution procedure */  
	void ResetSolver();
	
	/**
	 * @brief This method will reset the matrix associated with the solver
	 */
	 /** This is useful when the matrix needs to be recomputed in a non linear problem */
	virtual void ResetMatrix();
	
	/** @brief Updates the values of the preconditioner based on the values of the matrix */
	virtual void UpdateFrom(TPZAutoPointer<TPZMatrix<TVar> > mat);
	// /**
	// This method gives a preconditioner to share a matrix with the referring solver object
	// */
	//  virtual void SetMatrix(TPZMatrixSolver *solver);
	
	void AppendSolver(TPZMatrixSolver<TVar>& solve);
	
	virtual TPZSolver<TVar> * Clone() const;
	
	/** @brief Saveable specific methods */
	virtual int ClassId() const
	{
		return TPZSQUENCESOLVER_ID;
	}
	virtual void Write(TPZStream &buf, int withclassid);
	virtual void Read(TPZStream &buf, void *context);
	
	
private:    
	TPZStack < TPZMatrixSolver<TVar> * > fSolvers;
};

#endif //TPZSEQUENCESOLVER_H
