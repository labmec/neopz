/**
 * @file
 * @brief Contains the TPZFrontNonSym class which implements storage and decomposition process of the frontal matrix.
 */
/* Generated by Together */
template<class TVar>
class TPZEqnArray;

#ifndef TPZFRONTNONSYM_H
#define TPZFRONTNONSYM_H


#include "pzmatrix.h"
#include "pzstack.h"
#include "pzvec.h"
#include "TPZFront.h"

#include <math.h>
#include <iostream>
#include <fstream>
#include "TPZStackEqnStorage.h"
#include "TPZFileEqnStorage.h"


/** 
 * @brief Abstract class implements storage and decomposition process of the frontal matrix involving non-simetry characteristics. \ref frontal "Frontal"
 * @ingroup frontal
 */
/**
 * The Front matrix itself.
 * It is controled by TPZFrontMatrix. \n
 * TPZFrontNonSym is a non symmetrical matrix. It uses LU decomposition scheme.
 */
template<class TVar>
class TPZFrontNonSym : public TPZFront<TVar> {
public:
	/** @brief Type of matrix */
	std::string GetMatrixType();
	
    /** Static main used for testing */
	static void main();
    /** @brief Simple destructor */
    ~TPZFrontNonSym();
    /** @brief Simple constructor */
    TPZFrontNonSym();
    /** @brief Constructor with a initial size parameter */
	TPZFrontNonSym(int64_t GlobalSize);
	
	TPZFrontNonSym(const TPZFrontNonSym &cp);
    
    /// Set the decomposition type
    virtual void SetDecomposeType(DecomposeType dectype) override
    {
        if (dectype == ELU) {
            this->fDecomposeType = dectype;
        }
        else
        {
            DebugStop();
        }
    }
    

    /**
     * @brief Decompose these equations and put the result in eqnarray. \n
     * Default decompose method is LU
	 * @param mineq starting index of equations to be decomposed
	 * @param maxeq finishing index of equations to be decomposed
	 * @param result result of decomposition.
     */
    void DecomposeEquations(int64_t mineq, int64_t maxeq, TPZEqnArray<TVar> & result);
	
    /** @brief Decompose these equations in a symbolic way and store freed indexes in fFree */
    void SymbolicDecomposeEquations(int64_t mineq, int64_t maxeq);
	
	/** @brief Add a contribution of a stiffness matrix using the indexes to compute the frontwidth */
	void SymbolicAddKel(TPZVec < int64_t > & destinationindex);
	
    /** @brief Compress data structure */
    void Compress();
	
	/** 
	 * @brief Expand the front matrix 
	 * @param largefrontsize New size of front
	 */
	void Expand(int largefrontsize);
	
    /**
     * @brief Returns the ith,jth element of the matrix. \n
     * \f$ (sourceindex[i],sourceindex[j]) \f$
     */
	TVar & Element(int64_t i, int64_t j) {
		return this->fData[this->fMaxFront*j + i];
	}
    
    /**
     * @brief Returns the ith,jth element of the matrix. \n
     * \f$ (sourceindex[i],sourceindex[j]) \f$
     */
    const TVar & Element(int64_t i, int64_t j) const{
        return this->fData[this->fMaxFront*j + i];
    }
    
    /** 
	 * @brief Add a contribution of a stiffness matrix
	 * @param elmat Already formed element matrix
	 * @param destinationindex Destine index on the global matrix
	 */
    void AddKel(TPZFMatrix<TVar> &elmat, TPZVec<int64_t> &destinationindex);
	
    /** 
	 * @brief Add a contribution of a stiffness matrix
	 * @param elmat Already formed element matrix
	 * @param sourceindex Source index
	 * @param destinationindex Destine index on the global matrix
	 */
    virtual void AddKel(TPZFMatrix<TVar> &elmat, TPZVec<int64_t> &sourceindex,  TPZVec<int64_t> &destinationindex);
	
	/** @brief Extract the front matrix */
	virtual void ExtractFrontMatrix(TPZFMatrix<TVar> &front) override;
        
        public:
int ClassId() const override;
	
private:    
	
    /** 
	 * @brief Decomposes ieq equation and add the result to EqnArray 
	 * @param ieq Index of equation to be decomposed
	 * @param eqnarray EqnArray to store resulting members
	 */
    void DecomposeOneEquation(int64_t ieq, TPZEqnArray<TVar> &eqnarray);
	
    /**
     * @brief Sets the global equation as freed, allowing the space \n
     * used by this equation to be used by future assembly processes. 
	 * @param global Global index to be freed.
     */
    void FreeGlobal(int64_t global);
    /** 
	 * @brief Returns a local index corresponding to a global equation number 
	 * @param global Global index inquired
	 */
    int Local(int64_t global);
	
public:
    /** @brief Returns the number of free equations */
	virtual int64_t NFree() override;
    /** 
	 * @brief Resets data structure 
	 * @param GlobalSize Initial global size to be used in reseting
	 */
	void Reset(int64_t GlobalSize=0);
    /** @brief Allocates data for Front */
	void AllocData();
	
    /** @brief It prints TPZFront data */
	void Print(const char *name, std::ostream& out) const;
	void PrintGlobal(const char *name, std::ostream& out);
	
	
private:
	
    /** @link dependency */
    /*#  TPZStackEqnStorage lnkTPZStackEqnStorage; */
	
    /** @link dependency */
    /*#  TPZFileEqnStorage lnkTPZFileEqnStorage; */
	
public:
	
	virtual void TensorProductIJ(int ithread, typename TPZFront<TVar>::STensorProductMTData *data) override;
	
};

template<class TVar>
int TPZFrontNonSym<TVar>::ClassId() const{
    return Hash("TPZFrontNonSym") ^ TPZFront<TVar>::ClassId() << 1;
}


#endif //TPZFRONTNONSYM_H
